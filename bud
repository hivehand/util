#!/usr/bin/env ruby

# bud: brew-update descriptions
#
# With the output of `brew update` in the paste buffer, list the
# descriptions of the uninstalled formulae.

require 'json'
require 'colorize'

# TODO: Add HTML output as an option.
# TODO: Add automatic recognition of New/Updated sections.

# Take a block of text representing a table. Break into an array of rows, with
# each row an array of column entries.

def tablify(input)
  # Names are separated either by AT LEAST two spaces, or a newline.
  column_divider = /\s{2,}|\n/

  # Turn a succession of lines into an array of arrays representing a table.
  input.split("\n").inject([]) do |acc, line|
    acc << line.split(column_divider)
  end
end

# Given an array of arrays representing successive rows of a table, return a
# pivoted version of the table, with the original's columns turned into rows.

def pivot(table)
  max_length = table.reduce(0) do |max, row|
    ((current = row.length) > max) ? current : max
  end

  pivoted = []
  for i in 0..(max_length - 1)
    pivoted << table.map { |row| row[i] }.compact
  end

  pivoted
end


def get_metadata
  table = tablify(%x(pbpaste))

  # Pivot the table, then flatten it into a sequential array.
  flattened = pivot(table).flatten

  # Installed packages have their name-strings end with " (installed)".
  installed = / \(installed\)$/

  # Filter out the installed formulae.
  filtered = flattened.reject { |update| installed.match(update) }

  nameset = filtered.join(' ')

  JSON.parse(%x(brew info --json=v1 #{nameset}))
end


def stream_out(metadata)
  margin = metadata.map { |entry| entry['name'].length }.max

  metadata.each do |formula|
    name, desc, homepage = formula.values_at(
      *%w[name desc homepage]
    )
    printf("%s%s: %s\n",
           ' ' * (margin - name.length), name.colorize(:blue), desc)
    printf("%s  %s\n",
           ' ' * margin, homepage)
  end
end

def htmlify(metadata)

end

# ------------------

metadata = get_metadata
stream_out(metadata)
